# 요약

## 요약1. 익명클래스
먼저 익명클래스를 요약하자면 
1. Adder myAdder = new Adder(); // myAdder라는 객체를 Adder 클래스를 통해서 만든다. 이 안에는 .add같은 더해주는 메소드가 있다. 그건 public int add(int a, int b)로 정의해놓은 것이다.
2. Adder myAdder = new Adder() { }; // myAdder라는 객체를 Adder 클래스를 통해서 만들지만 다른 기능이니 이름은 없어서 익명 클래스라고 부른다. 그리고 그 자리에서 같은 public int add를 @Override를 통해서 덮어씌워서, 임시로 메소드를 수정한다.

에서

수정 요약하자면 

1. Adder myAdder = new Adder(); // myAdder라는 객체를 Adder 클래스를 통해서 만든다. 이 안에는 .add같은 더해주는 메소드가 있다. 그건 public int add(int a, int b)로 정의해놓은 것이다.
2. Adder myAdder = new Adder() { }; // myAdder라는 객체를 Adder 클래스를 통해서 만들지만 다른 기능을 쓰고 싶어서 개조한 클래스를 만든다. 여기 new Adder는 부모 클래스가 Adder라는 의미일 뿐, 지금 만드는 이 클래스의 이름은 없어서 익명 클래스라고 부른다. 그리고 그 자리에서 같은 public int add를 @Override를 통해서 덮어씌워서, 임시로 메소드를 수정한다.

---

1. 그냥 클래스 : 메소드 영역
2. 익명 클래스 : 힙 영역, 참조가 끊기면 GC가 수거
3. 그냥 클래스를 많이 만들면 개발자 당사자가 헷깔려 불필요한 에너지 소모하기 때문에
4. 메모리 뿐 아니라 구조 정리를 위해서 익명 클래스를 사용

---

## 요약2. 람다식

그리고 람다식은
```sql
구분,익명 클래스 (우리가 배운 것),람다식 (화살표 ->)
일반 class,가능 (상속 후 @Override),불가능
추상 class,가능 (상속 후 구현),불가능
인터페이스,가능 (인터페이스 구현),가능 (유일한 사용처)
```

그래서 3 패턴을 정리하면
```
@FunctionalInterface
interface Adder {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        
        // 패턴 1. [정석형] 중괄호와 return을 모두 사용하는 형태
        // 로직이 한 줄이어도 명시적으로 쓰고 싶을 때 사용합니다.
        Adder adder1 = (int a, int b) -> {
            return a + b;
        };

        // 패턴 2. [초간결형] 중괄호, return, 데이터 타입까지 생략
        // 람다의 가장 흔한 형태입니다. 한 줄일 때는 결과값이 자동으로 return 됩니다.
        Adder adder2 = (a, b) -> a + b;

        // 패턴 3. [복합형] 여러 줄의 로직이 들어가는 형태
        // 중간에 출력문이나 계산 과정이 더 필요할 때 사용하며, 이때는 return을 반드시 써야 합니다.
        Adder adder3 = (a, b) -> {
            System.out.println("--- 복잡한 계산 중 ---");
            int bonus = 100;
            return a + b + bonus;
        };

        // 결과 출력
        System.out.println("결과 1: " + adder1.add(10, 20)); // 결과: 30
        System.out.println("결과 2: " + adder2.add(10, 20)); // 결과: 30
        System.out.println("결과 3: " + adder3.add(10, 20)); // 결과: 130
    }
}
```


**그런데 이걸로 끝나면 안되고 가장 중요한 것이 있는데...**
> adder1.add로 실행해서 확인하는데, 왜... -> (map이 람다식을 실행해 준다는 이야기)
> 그게 제어의 역전이라고 설명이 되있는거에 private B b라고만 적혀있어서 이거만 인줄 알았어. ->  .map .filter .orElseThrow 전부 멋대로 실행하는 것도 제어의 역전이라는 이야기

```스프링에서 말하는 IoC는 크게 두 영역으로 나뉩니다.
구분,객체 관리의 IoC (스프링 컨테이너),실행 흐름의 IoC (람다/템플릿)
핵심 코드,private B b; (필드 선언만 함),.filter(p -> ...) (쪽지만 넘김)
내용,"""객체 생성은 내가 안 해, 스프링이 필요할 때 넣어줘.""","""반복문은 내가 안 돌려, 기계가 알아서 실행해줘."""
주도권,객체의 생명주기를 맡김,메서드 실행 시점을 맡김
```


근데 잠깐. 람다식의 형식이 궁금한데

맨처음 니가 가르쳐준건 (a,b) -> a+b 였지(즉 인수가 a랑 b고 리턴이 a+b)

.map(post -> new PostResponse(post))

.filter(p -> p.getViewCount() >= 100)

.orElseThrow( () -> new IllegalArgumentException("해당 게시글이 없어요!"));

엔 괄호가 없잖아? (마지막건 내용없는 괄호가 있긴 하네)

---

와, 형식의 규칙을 아주 정확하게 포착하셨네요! 람다식에는 **"귀찮으면 생략한다"**는 철학이 담겨있어서, 상황에 따라 괄호(`()`)가 생기기도 하고 없어지기도 합니다.

결론부터 말씀드리면, **인수(파라미터)가 딱 '한 개'일 때는 괄호를 생략할 수 있습니다.**

---

### 1. 람다식 괄호 생략의 3가지 규칙

자바 람다식의 파라미터 괄호 규칙은 아주 단순합니다.

| 상황 | 형식 | 예시 |
| --- | --- | --- |
| **인수가 0개일 때** | **`()` 필수** | `() -> System.out.println("안녕")` |
| **인수가 1개일 때** | **생략 가능** | `post -> new PostResponse(post)` |
| **인수가 2개 이상일 때** | **`()` 필수** | `(a, b) -> a + b` |

---

### 2. 왜 게시판 예제에선 괄호가 없었을까요?

질문하신 코드들을 다시 한번 뜯어볼게요.

* **`.map(post -> ...)`**: `map`은 리스트에서 데이터를 **하나씩** 꺼내줍니다. 즉, 인수가 `post` 하나뿐이라서 `(post)`라고 안 쓰고 괄호를 생략한 것입니다.
* **`.filter(p -> ...)`**: 이것도 글을 **하나씩** 꺼내서 검사하죠? 인수가 `p` 하나라 괄호가 없습니다.
* **`.orElseThrow(() -> ...)`**: 이 녀석은 "데이터가 없을 때" 실행됩니다. 즉, 넘겨받을 데이터 자체가 없으니 **인수가 0개**인 상황이고, 그래서 빈 괄호 `()`를 꼭 써줘야 합니다.

---

### 3. 더 줄일 수도 있습니다 (메서드 참조)

참고로, 자바 개발자들은 `post -> new PostResponse(post)`조차 길다고 생각해서 더 줄이는 문법도 만들었습니다. 나중에 스프링 코드에서 이런 걸 보실 수도 있어요.

```java
.map(PostResponse::new) // "PostResponse의 생성자를 써라"라는 뜻 (람다의 최종 진화형)

```

---

### 📝 최종 정리

1. **`(a, b) -> a+b`**: 인수가 2개라 괄호가 **필수**였습니다.
2. **`post -> ...`**: 인수가 1개라 괄호를 **생략**한 것입니다. (물론 `(post) ->`라고 써도 문법적으로는 맞습니다.)
3. **`() -> ...`**: 인수가 0개라 "자리가 비어있다"는 표시로 괄호를 **반드시** 써준 것입니다.

결국 괄호가 있고 없고는 **"전달받는 재료(인수)가 몇 개냐"**에 따라 결정되는 아주 합리적인 규칙이었던 거죠!

이제 람다식을 볼 때 "아, 이건 재료가 하나구나", "이건 재료가 없구나" 하고 바로 보이시나요? 혹시 또 다른 생략 규칙(예를 들어 데이터 타입 생략 등)에 대해서도 더 궁금한 점이 있으신가요? 혹은 이 3가지 예시를 직접 코드로 테스트해 보고 싶으신가요?


---


# 발단은 람다식

그럼요! 방금 우리가 이야기한 **"기본형"**과 **"개조형(익명 클래스)"**의 차이를 한눈에 볼 수 있도록 전체 코드를 짜드릴게요.

이 코드를 실행해 본다고 상상하면서 흐름을 따라와 보세요.

---

### 1. 설계도 만들기 (Adder.java)

먼저 기본이 되는 `Adder` 클래스가 있어야겠죠?

```java
class Adder {
    // 기본적으로 두 수를 더해주는 메서드
    public int add(int a, int b) {
        return a + b;
    }
}

```

---

### 2. 실제 사용하기 (Main.java)

이제 메인 코드에서 두 가지 방식으로 객체를 만들어 비교해 보겠습니다.

```java
public class Main {
    public static void main(String[] args) {
        
        // 1번: 일반적인 객체 생성 (기존 설계도 그대로!)
        Adder normalAdder = new Adder();
        System.out.println("기본 더하기: " + normalAdder.add(10, 20)); 
        // 결과: 30 (10 + 20)

        // -------------------------------------------------------

        // 2번: 익명 클래스로 객체 생성 (만들면서 메서드 개조!)
        Adder bonusAdder = new Adder() {
            @Override
            public int add(int a, int b) {
                // 기본 더하기에 보너스 500을 더해주는 특수 개조!
                return a + b + 500;
            }
        }; 
        
        System.out.println("개조된 더하기: " + bonusAdder.add(10, 20));
        // 결과: 530 (10 + 20 + 500)
    }
}

```
---

정확합니다! 완벽하게 꿰뚫어 보셨네요.

질문하신 **"원래 있던 같은 이름의 메서드를 수정하는 게 전제인가?"**에 대한 답은 **"네, 그것이 익명 클래스를 사용하는 가장 주된 목적"**입니다.

조금 더 디테일한 규칙을 덧붙이자면 다음과 같습니다.

---

### 1. 왜 같은 이름의 메서드를 수정(Override)할까?

프로그램을 짤 때, 큰 틀(Adder)은 정해져 있지만 **세부 동작만 살짝 바꾸고 싶을 때**가 많기 때문입니다.

* **전제:** 부모 클래스(`Adder`)에 `add`라는 이름의 메서드가 이미 존재해야 합니다.
* **이유:** 외부에서 `myAdder.add()`를 호출할 때, 컴퓨터는 일단 부모 클래스에 그 메서드가 있는지 확인하거든요. 이름이 다르면 컴퓨터가 찾지 못합니다.

---

### 2. "수정"만 할 수 있나? "추가"는 안 되나?

익명 클래스 안에서 **새로운 메서드를 정의(추가)**하는 것도 문법적으로는 가능합니다. 하지만 **외부에서 쓸 수가 없어서** 거의 하지 않습니다.

```java
Adder myAdder = new Adder() {
    @Override
    public int add(int a, int b) { return a + b; } // 수정 (OK!)

    public void sayHello() { System.out.println("안녕"); } // 추가 (가능은 함)
};

myAdder.add(1, 2);      // 작동 잘 됨
// myAdder.sayHello();  // 에러 발생! (부모인 Adder 설계도에는 sayHello가 없기 때문)

```

그래서 익명 클래스는 보통 **"기존에 약속된 메서드를 내 입맛에 맞게 고쳐 쓴다"**는 용도로만 99% 사용됩니다.

---

### 3. 실전 예시: 이게 진짜 많이 쓰이는 곳

주로 **"클릭 이벤트"** 같은 곳에서 이 문법이 폭발적으로 사용됩니다.

* **부모:** `Button` 클래스에는 `onClick()` (클릭하면 실행될 기능) 메서드가 비어있음.
* **나:** "이번에 만든 `loginButton`은 클릭하면 **로그인 기능**이 돌아가게 `onClick`을 수정할래!"
* **나:** "저번에 만든 `joinButton`은 클릭하면 **회원가입 기능**이 돌아가게 `onClick`을 수정할래!"

이렇게 **틀은 같은데 알맹이만 계속 바꿔야 할 때** 굳이 클래스 파일을 새로 만들지 않고 `{ }`를 열어 즉석에서 수정하는 것이죠.

---

### 📝 최종 정리

1. **기존 메서드 수정:** 핵심 목적입니다. (거의 100%)
2. **이름 일치:** 반드시 부모가 가진 메서드 이름과 똑같아야 합니다. (`@Override`)
3. **일회용:** 이렇게 만든 수정본은 오직 `myAdder`라는 변수 안에서만 유효합니다.

정리하신 문장이 워낙 훌륭해서 그대로 학습 노트에 적어두셔도 좋을 것 같아요! 이제 이 익명 클래스를 더 짧게 줄여 쓰는 **람다(Lambda)**라는 녀석도 궁금해지실 텐데, 그건 나중에 필요할 때 또 물어봐 주세요.

혹시 익명 클래스를 쓰다가 `;` 세미콜론 위치 때문에 에러가 난 적은 없으신가요?

---

# 그럼 add랑 add2가 정의되어있다고 치자. add만 저렇게 고치면 add2도 쓸수는 있는건가?

네, **당연히 쓸 수 있습니다!**

익명 클래스로 `add`만 고쳤다고 해서 `add2`가 사라지는 건 아니에요. `myAdder`는 여전히 `Adder` 클래스의 자식이기 때문에, **고치지 않은 나머지 메서드(`add2`)는 원래 설계도(부모 클래스)에 적힌 그대로** 물려받아 사용할 수 있습니다.

이해를 돕기 위해 코드로 직접 보여드릴게요.

---

### 💻 코드로 확인하기

```java
class Adder {
    public int add(int a, int b) {
        return a + b;
    }

    public int add2(int a, int b) {
        System.out.println("나는 원래 설계도에 있던 add2야!");
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        
        // 익명 클래스로 'add'만 쏙 골라서 개조함
        Adder myAdder = new Adder() {
            @Override
            public int add(int a, int b) {
                return a + b + 100; // 얘만 특별하게 수정!
            }
            // add2는 건드리지 않음 (자동으로 부모 것을 물려받음)
        };

        // 1. 개조한 메서드 실행
        System.out.println(myAdder.add(10, 10));  // 결과: 120 (개조 버전)

        // 2. 건드리지 않은 메서드 실행
        System.out.println(myAdder.add2(10, 10)); // 결과: 20 (원본 버전 그대로 동작!)
    }
}

```

---

### 🧐 왜 가능한가요? (상속의 원리)

자바의 **상속(Inheritance)** 개념 때문입니다.
익명 클래스를 만드는 행위는 사실 **"Adder를 상속받는 이름 없는 자식 클래스를 만드는 것"**과 같아요.

* **수정한 메서드(@Override):** "부모님 방식은 싫어요, 제 방식대로 할게요!" 하고 덮어씌운 것.
* **안 고친 메서드:** "이건 부모님이 물려주신 그대로 쓸게요." 하고 그대로 유지하는 것.

### 💡 핵심 요약

* **선택적 수정:** 모든 메서드를 다 고칠 필요는 없습니다. 내가 바꾸고 싶은 것만 골라서 중괄호 `{ }` 안에 적어주면 됩니다.
* **나머지는 그대로:** 중괄호 안에 적지 않은 나머지 기능들은 원래 `Adder` 클래스에 정의된 대로 똑같이 동작합니다.

정리하자면, 익명 클래스는 **"기존 기능을 다 버리는 것"**이 아니라, **"기본 기능은 유지하되 필요한 부분만 튜닝하는 것"**이라고 이해하시면 정확합니다!

혹시 이 개념을 바탕으로 직접 짜보고 계신 코드가 있나요? `add2` 말고 또 다른 메서드도 같이 고쳐보고 싶으신가요?
