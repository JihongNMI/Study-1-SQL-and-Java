# 요약

## 요약1. 익명클래스
먼저 익명클래스를 요약하자면 
1. Adder myAdder = new Adder(); // myAdder라는 객체를 Adder 클래스를 통해서 만든다. 이 안에는 .add같은 더해주는 메소드가 있다. 그건 public int add(int a, int b)로 정의해놓은 것이다.
2. Adder myAdder = new Adder() { }; // myAdder라는 객체를 Adder 클래스를 통해서 만들지만 다른 기능이니 이름은 없어서 익명 클래스라고 부른다. 그리고 그 자리에서 같은 public int add를 @Override를 통해서 덮어씌워서, 임시로 메소드를 수정한다.

에서

수정 요약하자면 

1. Adder myAdder = new Adder(); // myAdder라는 객체를 Adder 클래스를 통해서 만든다. 이 안에는 .add같은 더해주는 메소드가 있다. 그건 public int add(int a, int b)로 정의해놓은 것이다.
2. Adder myAdder = new Adder() { }; // myAdder라는 객체를 Adder 클래스를 통해서 만들지만 다른 기능을 쓰고 싶어서 개조한 클래스를 만든다. 여기 new Adder는 부모 클래스가 Adder라는 의미일 뿐, 지금 만드는 이 클래스의 이름은 없어서 익명 클래스라고 부른다. 그리고 그 자리에서 같은 public int add를 @Override를 통해서 덮어씌워서, 임시로 메소드를 수정한다.

---

1. 그냥 클래스 : 메소드 영역
2. 익명 클래스 : 힙 영역, 참조가 끊기면 GC가 수거
3. 그냥 클래스를 많이 만들면 개발자 당사자가 헷깔려 불필요한 에너지 소모하기 때문에
4. 메모리 뿐 아니라 구조 정리를 위해서 익명 클래스를 사용

---

## 요약2. 람다식

그리고 람다식은
```sql
구분,익명 클래스 (우리가 배운 것),람다식 (화살표 ->)
일반 class,가능 (상속 후 @Override),불가능
추상 class,가능 (상속 후 구현),불가능
인터페이스,가능 (인터페이스 구현),가능 (유일한 사용처)
```

그래서 3 패턴을 정리하면
```
@FunctionalInterface
interface Adder {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        
        // 패턴 1. [정석형] 중괄호와 return을 모두 사용하는 형태
        // 로직이 한 줄이어도 명시적으로 쓰고 싶을 때 사용합니다.
        Adder adder1 = (int a, int b) -> {
            return a + b;
        };

        // 패턴 2. [초간결형] 중괄호, return, 데이터 타입까지 생략
        // 람다의 가장 흔한 형태입니다. 한 줄일 때는 결과값이 자동으로 return 됩니다.
        Adder adder2 = (a, b) -> a + b;

        // 패턴 3. [복합형] 여러 줄의 로직이 들어가는 형태
        // 중간에 출력문이나 계산 과정이 더 필요할 때 사용하며, 이때는 return을 반드시 써야 합니다.
        Adder adder3 = (a, b) -> {
            System.out.println("--- 복잡한 계산 중 ---");
            int bonus = 100;
            return a + b + bonus;
        };

        // 결과 출력
        System.out.println("결과 1: " + adder1.add(10, 20)); // 결과: 30
        System.out.println("결과 2: " + adder2.add(10, 20)); // 결과: 30
        System.out.println("결과 3: " + adder3.add(10, 20)); // 결과: 130
    }
}
```


**그런데 이걸로 끝나면 안되고 가장 중요한 것이 있는데...**
> adder1.add로 실행해서 확인하는데, 왜... -> (map이 람다식을 실행해 준다는 이야기)
> 그게 제어의 역전이라고 설명이 되있는거에 private B b라고만 적혀있어서 이거만 인줄 알았어. ->  .map .filter .orElseThrow 전부 멋대로 실행하는 것도 제어의 역전이라는 이야기

# 3. 왜 람다식 생긴게 예시랑 게시판 코드가 다른가?(제어의 역전 이야기)

```스프링에서 말하는 IoC는 크게 두 영역으로 나뉩니다.
구분,객체 관리의 IoC (스프링 컨테이너),실행 흐름의 IoC (람다/템플릿)
핵심 코드,private B b; (필드 선언만 함),.filter(p -> ...) (쪽지만 넘김)
내용,"""객체 생성은 내가 안 해, 스프링이 필요할 때 넣어줘.""","""반복문은 내가 안 돌려, 기계가 알아서 실행해줘."""
주도권,객체의 생명주기를 맡김,메서드 실행 시점을 맡김
```


근데 잠깐. 람다식의 형식이 궁금한데

맨처음 니가 가르쳐준건 (a,b) -> a+b 였지(즉 인수가 a랑 b고 리턴이 a+b)

.map(post -> new PostResponse(post))

.filter(p -> p.getViewCount() >= 100)

.orElseThrow( () -> new IllegalArgumentException("해당 게시글이 없어요!"));

엔 괄호가 없잖아? (마지막건 내용없는 괄호가 있긴 하네)

---

와, 형식의 규칙을 아주 정확하게 포착하셨네요! 람다식에는 **"귀찮으면 생략한다"**는 철학이 담겨있어서, 상황에 따라 괄호(`()`)가 생기기도 하고 없어지기도 합니다.

결론부터 말씀드리면, **인수(파라미터)가 딱 '한 개'일 때는 괄호를 생략할 수 있습니다.**

---

### 1. 람다식 괄호 생략의 3가지 규칙

자바 람다식의 파라미터 괄호 규칙은 아주 단순합니다.

| 상황 | 형식 | 예시 |
| --- | --- | --- |
| **인수가 0개일 때** | **`()` 필수** | `() -> System.out.println("안녕")` |
| **인수가 1개일 때** | **생략 가능** | `post -> new PostResponse(post)` |
| **인수가 2개 이상일 때** | **`()` 필수** | `(a, b) -> a + b` |

---

### 2. 왜 게시판 예제에선 괄호가 없었을까요?

질문하신 코드들을 다시 한번 뜯어볼게요.

* **`.map(post -> ...)`**: `map`은 리스트에서 데이터를 **하나씩** 꺼내줍니다. 즉, 인수가 `post` 하나뿐이라서 `(post)`라고 안 쓰고 괄호를 생략한 것입니다.
* **`.filter(p -> ...)`**: 이것도 글을 **하나씩** 꺼내서 검사하죠? 인수가 `p` 하나라 괄호가 없습니다.
* **`.orElseThrow(() -> ...)`**: 이 녀석은 "데이터가 없을 때" 실행됩니다. 즉, 넘겨받을 데이터 자체가 없으니 **인수가 0개**인 상황이고, 그래서 빈 괄호 `()`를 꼭 써줘야 합니다.

---

### 3. 더 줄일 수도 있습니다 (메서드 참조)

참고로, 자바 개발자들은 `post -> new PostResponse(post)`조차 길다고 생각해서 더 줄이는 문법도 만들었습니다. 나중에 스프링 코드에서 이런 걸 보실 수도 있어요.

```java
.map(PostResponse::new) // "PostResponse의 생성자를 써라"라는 뜻 (람다의 최종 진화형)

```

---

### 📝 최종 정리

1. **`(a, b) -> a+b`**: 인수가 2개라 괄호가 **필수**였습니다.
2. **`post -> ...`**: 인수가 1개라 괄호를 **생략**한 것입니다. (물론 `(post) ->`라고 써도 문법적으로는 맞습니다.)
3. **`() -> ...`**: 인수가 0개라 "자리가 비어있다"는 표시로 괄호를 **반드시** 써준 것입니다.

결국 괄호가 있고 없고는 **"전달받는 재료(인수)가 몇 개냐"**에 따라 결정되는 아주 합리적인 규칙이었던 거죠!

이제 람다식을 볼 때 "아, 이건 재료가 하나구나", "이건 재료가 없구나" 하고 바로 보이시나요? 혹시 또 다른 생략 규칙(예를 들어 데이터 타입 생략 등)에 대해서도 더 궁금한 점이 있으신가요? 혹은 이 3가지 예시를 직접 코드로 테스트해 보고 싶으신가요?

---

# 그리고 리액트 해설에서 나왔던 이중람다식의 정체

원래 이 한줄을 공부하고 있었는데 const createAdder = (x) => (y) => x + y;

근데 자바의 x -> y -> x + y; 랑 똑같다고 했는데, 실제로 쓰는게 1개 람다식 쓰는거랑 뭔가 달라서 이해를 못했어

---

오, 지금 보고 계신 그 코드는 **'함수형 프로그래밍'**의 꽃이라고 불리는 **커링(Currying)**이라는 기법입니다!

JavaScript의 `const createAdder = (x) => (y) => x + y;`와 Java의 `x -> y -> x + y`는 구조적으로 완전히 동일합니다. 하지만 우리가 평소에 쓰던 `(a, b) -> a + b`와는 결정적인 차이가 있어요.

---

### 1. 무엇이 다른가요? (합체 vs 분리)

* **일반 람다 `(x, y) -> x + y**`: "재료 `x`와 `y`를 **동시에** 주면, 바로 더해서 결과를 줄게!" (일체형 기계)
* **2중 람다 `x -> y -> x + y**`: "재료 `x`를 먼저 주면, **'y를 받으면 x와 더해주는 또 다른 기계'**를 만들어서 줄게!" (조립형 기계)

---

### 2. 왜 이렇게 쓰나요? (재사용의 마법)

이게 왜 좋은지는 실례를 보면 확 와닿습니다. `x`에 `10`을 미리 넣어둔 **'10 전용 더하기 기계'**를 만들 수 있거든요.

**Java 예시:**

```java
// 1. 기계를 만드는 기계 정의
Function<Integer, Function<Integer, Integer>> makeAdder = x -> y -> x + y;

// 2. "10을 더해주는 기계"를 미리 생성 (x = 10 고정)
Function<Integer, Integer> add10 = makeAdder.apply(10); 

// 3. 나중에 필요할 때 y값만 넣어서 사용
System.out.println(add10.apply(5));  // 15
System.out.println(add10.apply(20)); // 30

```

---

### 3. 구조가 왜 `x -> y -> x + y` 인가요?

괄호를 넣어서 가독성을 높여보면 이해가 빠릅니다.
`x -> (y -> (x + y))`

1. **`x -> ...`**: 첫 번째 람다입니다. `x`를 받습니다.
2. **`(y -> x + y)`**: 첫 번째 람다가 **결과물로 내뱉는 '값'**인데, 그 값이 하필이면 **또 다른 람다식**인 것입니다.
3. 이때 안쪽 람다는 바깥에서 받은 `x`를 기억(Closure)하고 있습니다.

---

### 4. 실무에서의 차이점

| 구분 | 일반 람다 `(x, y) -> x+y` | 2중 람다 (커링) `x -> y -> x+y` |
| --- | --- | --- |
| **호출 방식** | `add(10, 5)` (한번에 호출) | `add.apply(10).apply(5)` (단계별 호출) |
| **유연성** | 무조건 인자 2개가 다 있어야 함 | 인자를 하나만 넣고 '중간 단계 기계'를 보관 가능 |
| **용도** | 단순 계산 | 설정값(x)을 미리 세팅해두고 나중에 로직(y)만 바꿀 때 |

---

### 📝 핵심 정리

질문자님이 보신 그 코드는 **"인자를 하나씩 천천히 받겠다"**는 의도가 담긴 코드입니다.

* `x ->` : "일단 첫 번째 설정값 `x`를 받아둘게."
* `y -> x + y` : "그다음 진짜 데이터 `y`가 들어오면 아까 받은 `x`랑 더해줄게!"

JS나 Java나 문법만 살짝 다를 뿐, **"함수를 리턴하는 함수"**라는 개념은 똑같습니다. 이 개념이 잡히면 나중에 리액트(React)의 고차 컴포넌트나 스프링의 복잡한 설정 로직을 볼 때 "아, 이거 2중 람다네!" 하고 바로 알아보실 수 있을 거예요.

이제 `(x, y)`와 `x -> y`가 왜 다른 맛인지 느껴지시나요? 이 '기계를 만드는 기계'라는 개념이 혹시 너무 추상적으로 느껴지진 않으세요? :)

---

add10을 만들면 이건 무조건 y값을 얻어왔을때 10을 더하도록 동작한다는거네

---

정확합니다! 아주 명쾌하게 핵심을 짚으셨어요.

`add10`은 더 이상 '어떻게 더할지' 고민하는 기계가 아니라, **"무엇이 들어오든 일단 10을 더하고 본다"**라는 특수 목적을 가진 **'전용 기계'**로 고정된 상태입니다.

이 원리를 완벽히 파악하기 위해, `add10`의 내부를 현미경으로 들여다본다고 상상해 보세요.

---

### 1. `add10`의 내부 상태

원래 람다식은 `x -> y -> x + y`였죠? 여기서 `makeAdder.apply(10)`을 하는 순간, 자바(또는 JS)는 내부적으로 이런 짓을 합니다.

* **바깥쪽 `x` 자리에 `10`을 박아버립니다.**
* 결과적으로 `add10`의 실제 모습은 내부적으로 **`y -> 10 + y`**와 같은 상태가 되어버린 거죠.

---

### 2. 왜 이게 "무조건" 그렇게 동작하나요? (Closure의 개념)

이걸 프로그래밍 언어에서는 **클로저(Closure)**라고 부릅니다.
`add10`이라는 기계가 만들어질 때, 그 주변 환경(즉, `x = 10`이라는 상황)을 **통째로 기억해서 주머니에 넣고 태어나기 때문**입니다.

그래서 나중에 우리가 억지로 `x`를 바꾸려 해도, 이미 `add10`의 주머니 속 `x`는 `10`으로 굳어 있어서 바꿀 수 없습니다. 오직 `y`값만 새로 받을 수 있는 거죠.

---

### 3. 실무에서의 활용: "템플릿 만들기"

이걸 단순히 숫자 더하기가 아니라 실무적인 상황에 대입해 보면 왜 쓰는지 확 와닿습니다.

```javascript
// JS 예시: 로그 앞에 [서버이름]을 붙여주는 로그 생성기
const createLogger = (serverName) => (message) => `[${serverName}] ${message}`;

// "결제서버" 전용 로그 기계를 미리 만들어둠
const paymentLog = createLogger("결제서버");

// 이제 메시지만 던지면 알아서 서버이름이 붙어서 나옴
console.log(paymentLog("결제 시작")); // "[결제서버] 결제 시작"
console.log(paymentLog("결제 완료")); // "[결제서버] 결제 완료"

```

---

### 📝 요약하자면

1. **커스터마이징 완료:** `add10`은 `x`라는 변수를 `10`이라는 상수로 바꿔치기한 상태의 람다식입니다.
2. **대기 중:** 이제 이 기계는 `y`라는 재료가 들어오기만을 목 빠지게 기다리는 **'반쪽짜리' 기계**입니다.
3. **확정적 동작:** 따라서 `y`가 들어오는 순간, 무조건 `10`을 더하는 동작이 수행됩니다.

질문자님이 이해하신 대로 **"무조건 10을 더하도록 동작한다"**는 점이 바로 이 기법의 무서운 점이자 매력입니다. '설정(x)'과 '실행(y)'을 분리한 것이죠!

이제 `(x) => (y) => x + y` 같은 형태를 봐도 전혀 쫄지(당황하지) 않으시겠죠? 혹시 이 '설정값을 미리 박아둔다'는 개념이 스프링의 어떤 부분과 닮았다는 느낌이 드시나요? (힌트: 빈(Bean) 설정과 비슷하답니다! 😉)

---


# 본문 : 발단은 람다식

그럼요! 방금 우리가 이야기한 **"기본형"**과 **"개조형(익명 클래스)"**의 차이를 한눈에 볼 수 있도록 전체 코드를 짜드릴게요.

이 코드를 실행해 본다고 상상하면서 흐름을 따라와 보세요.

---

### 1. 설계도 만들기 (Adder.java)

먼저 기본이 되는 `Adder` 클래스가 있어야겠죠?

```java
class Adder {
    // 기본적으로 두 수를 더해주는 메서드
    public int add(int a, int b) {
        return a + b;
    }
}

```

---

### 2. 실제 사용하기 (Main.java)

이제 메인 코드에서 두 가지 방식으로 객체를 만들어 비교해 보겠습니다.

```java
public class Main {
    public static void main(String[] args) {
        
        // 1번: 일반적인 객체 생성 (기존 설계도 그대로!)
        Adder normalAdder = new Adder();
        System.out.println("기본 더하기: " + normalAdder.add(10, 20)); 
        // 결과: 30 (10 + 20)

        // -------------------------------------------------------

        // 2번: 익명 클래스로 객체 생성 (만들면서 메서드 개조!)
        Adder bonusAdder = new Adder() {
            @Override
            public int add(int a, int b) {
                // 기본 더하기에 보너스 500을 더해주는 특수 개조!
                return a + b + 500;
            }
        }; 
        
        System.out.println("개조된 더하기: " + bonusAdder.add(10, 20));
        // 결과: 530 (10 + 20 + 500)
    }
}

```
---

정확합니다! 완벽하게 꿰뚫어 보셨네요.

질문하신 **"원래 있던 같은 이름의 메서드를 수정하는 게 전제인가?"**에 대한 답은 **"네, 그것이 익명 클래스를 사용하는 가장 주된 목적"**입니다.

조금 더 디테일한 규칙을 덧붙이자면 다음과 같습니다.

---

### 1. 왜 같은 이름의 메서드를 수정(Override)할까?

프로그램을 짤 때, 큰 틀(Adder)은 정해져 있지만 **세부 동작만 살짝 바꾸고 싶을 때**가 많기 때문입니다.

* **전제:** 부모 클래스(`Adder`)에 `add`라는 이름의 메서드가 이미 존재해야 합니다.
* **이유:** 외부에서 `myAdder.add()`를 호출할 때, 컴퓨터는 일단 부모 클래스에 그 메서드가 있는지 확인하거든요. 이름이 다르면 컴퓨터가 찾지 못합니다.

---

### 2. "수정"만 할 수 있나? "추가"는 안 되나?

익명 클래스 안에서 **새로운 메서드를 정의(추가)**하는 것도 문법적으로는 가능합니다. 하지만 **외부에서 쓸 수가 없어서** 거의 하지 않습니다.

```java
Adder myAdder = new Adder() {
    @Override
    public int add(int a, int b) { return a + b; } // 수정 (OK!)

    public void sayHello() { System.out.println("안녕"); } // 추가 (가능은 함)
};

myAdder.add(1, 2);      // 작동 잘 됨
// myAdder.sayHello();  // 에러 발생! (부모인 Adder 설계도에는 sayHello가 없기 때문)

```

그래서 익명 클래스는 보통 **"기존에 약속된 메서드를 내 입맛에 맞게 고쳐 쓴다"**는 용도로만 99% 사용됩니다.

---

### 3. 실전 예시: 이게 진짜 많이 쓰이는 곳

주로 **"클릭 이벤트"** 같은 곳에서 이 문법이 폭발적으로 사용됩니다.

* **부모:** `Button` 클래스에는 `onClick()` (클릭하면 실행될 기능) 메서드가 비어있음.
* **나:** "이번에 만든 `loginButton`은 클릭하면 **로그인 기능**이 돌아가게 `onClick`을 수정할래!"
* **나:** "저번에 만든 `joinButton`은 클릭하면 **회원가입 기능**이 돌아가게 `onClick`을 수정할래!"

이렇게 **틀은 같은데 알맹이만 계속 바꿔야 할 때** 굳이 클래스 파일을 새로 만들지 않고 `{ }`를 열어 즉석에서 수정하는 것이죠.

---

### 📝 최종 정리

1. **기존 메서드 수정:** 핵심 목적입니다. (거의 100%)
2. **이름 일치:** 반드시 부모가 가진 메서드 이름과 똑같아야 합니다. (`@Override`)
3. **일회용:** 이렇게 만든 수정본은 오직 `myAdder`라는 변수 안에서만 유효합니다.

정리하신 문장이 워낙 훌륭해서 그대로 학습 노트에 적어두셔도 좋을 것 같아요! 이제 이 익명 클래스를 더 짧게 줄여 쓰는 **람다(Lambda)**라는 녀석도 궁금해지실 텐데, 그건 나중에 필요할 때 또 물어봐 주세요.

혹시 익명 클래스를 쓰다가 `;` 세미콜론 위치 때문에 에러가 난 적은 없으신가요?

---

# 그럼 add랑 add2가 정의되어있다고 치자. add만 저렇게 고치면 add2도 쓸수는 있는건가?

네, **당연히 쓸 수 있습니다!**

익명 클래스로 `add`만 고쳤다고 해서 `add2`가 사라지는 건 아니에요. `myAdder`는 여전히 `Adder` 클래스의 자식이기 때문에, **고치지 않은 나머지 메서드(`add2`)는 원래 설계도(부모 클래스)에 적힌 그대로** 물려받아 사용할 수 있습니다.

이해를 돕기 위해 코드로 직접 보여드릴게요.

---

### 💻 코드로 확인하기

```java
class Adder {
    public int add(int a, int b) {
        return a + b;
    }

    public int add2(int a, int b) {
        System.out.println("나는 원래 설계도에 있던 add2야!");
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        
        // 익명 클래스로 'add'만 쏙 골라서 개조함
        Adder myAdder = new Adder() {
            @Override
            public int add(int a, int b) {
                return a + b + 100; // 얘만 특별하게 수정!
            }
            // add2는 건드리지 않음 (자동으로 부모 것을 물려받음)
        };

        // 1. 개조한 메서드 실행
        System.out.println(myAdder.add(10, 10));  // 결과: 120 (개조 버전)

        // 2. 건드리지 않은 메서드 실행
        System.out.println(myAdder.add2(10, 10)); // 결과: 20 (원본 버전 그대로 동작!)
    }
}

```

---

### 🧐 왜 가능한가요? (상속의 원리)

자바의 **상속(Inheritance)** 개념 때문입니다.
익명 클래스를 만드는 행위는 사실 **"Adder를 상속받는 이름 없는 자식 클래스를 만드는 것"**과 같아요.

* **수정한 메서드(@Override):** "부모님 방식은 싫어요, 제 방식대로 할게요!" 하고 덮어씌운 것.
* **안 고친 메서드:** "이건 부모님이 물려주신 그대로 쓸게요." 하고 그대로 유지하는 것.

### 💡 핵심 요약

* **선택적 수정:** 모든 메서드를 다 고칠 필요는 없습니다. 내가 바꾸고 싶은 것만 골라서 중괄호 `{ }` 안에 적어주면 됩니다.
* **나머지는 그대로:** 중괄호 안에 적지 않은 나머지 기능들은 원래 `Adder` 클래스에 정의된 대로 똑같이 동작합니다.

정리하자면, 익명 클래스는 **"기존 기능을 다 버리는 것"**이 아니라, **"기본 기능은 유지하되 필요한 부분만 튜닝하는 것"**이라고 이해하시면 정확합니다!

혹시 이 개념을 바탕으로 직접 짜보고 계신 코드가 있나요? `add2` 말고 또 다른 메서드도 같이 고쳐보고 싶으신가요?
