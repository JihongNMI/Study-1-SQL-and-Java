# 요약

먼저 익명클래스를 요약하자면 
1. Adder myAdder = new Adder(); // myAdder라는 객체를 Adder 클래스를 통해서 만든다. 이 안에는 .add같은 더해주는 메소드가 있다. 그건 public int add(int a, int b)로 정의해놓은 것이다.
2. Adder myAdder = new Adder() { }; // myAdder라는 객체를 Adder 클래스를 통해서 만들지만 다른 기능이니 이름은 없어서 익명 클래스라고 부른다. 그리고 그 자리에서 같은 public int add를 @Override를 통해서 덮어씌워서, 임시로 메소드를 수정한다.

에서

수정 요약하자면 

1. Adder myAdder = new Adder(); // myAdder라는 객체를 Adder 클래스를 통해서 만든다. 이 안에는 .add같은 더해주는 메소드가 있다. 그건 public int add(int a, int b)로 정의해놓은 것이다.
2. Adder myAdder = new Adder() { }; // myAdder라는 객체를 Adder 클래스를 통해서 만들지만 다른 기능을 쓰고 싶어서 개조한 클래스를 만든다. 여기 new Adder는 부모 클래스가 Adder라는 의미일 뿐, 지금 만드는 이 클래스의 이름은 없어서 익명 클래스라고 부른다. 그리고 그 자리에서 같은 public int add를 @Override를 통해서 덮어씌워서, 임시로 메소드를 수정한다.

---

1. 그냥 클래스 : 메소드 영역
2. 익명 클래스 : 힙 영역, 참조가 끊기면 GC가 수거
3. 그냥 클래스를 많이 만들면 개발자 당사자가 헷깔려 불필요한 에너지 소모하기 때문에
4. 메모리 뿐 아니라 구조 정리를 위해서 익명 클래스를 사용

---

그리고 람다식은
```sql
구분,익명 클래스 (우리가 배운 것),람다식 (화살표 ->)
일반 class,가능 (상속 후 @Override),불가능
추상 class,가능 (상속 후 구현),불가능
인터페이스,가능 (인터페이스 구현),가능 (유일한 사용처)
```

그래서 3 패턴을 정리하면
```
@FunctionalInterface
interface Adder {
    int add(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        
        // 패턴 1. [정석형] 중괄호와 return을 모두 사용하는 형태
        // 로직이 한 줄이어도 명시적으로 쓰고 싶을 때 사용합니다.
        Adder adder1 = (int a, int b) -> {
            return a + b;
        };

        // 패턴 2. [초간결형] 중괄호, return, 데이터 타입까지 생략
        // 람다의 가장 흔한 형태입니다. 한 줄일 때는 결과값이 자동으로 return 됩니다.
        Adder adder2 = (a, b) -> a + b;

        // 패턴 3. [복합형] 여러 줄의 로직이 들어가는 형태
        // 중간에 출력문이나 계산 과정이 더 필요할 때 사용하며, 이때는 return을 반드시 써야 합니다.
        Adder adder3 = (a, b) -> {
            System.out.println("--- 복잡한 계산 중 ---");
            int bonus = 100;
            return a + b + bonus;
        };

        // 결과 출력
        System.out.println("결과 1: " + adder1.add(10, 20)); // 결과: 30
        System.out.println("결과 2: " + adder2.add(10, 20)); // 결과: 30
        System.out.println("결과 3: " + adder3.add(10, 20)); // 결과: 130
    }
}
```


**그런데 이걸로 끝나면 안되고 가장 중요한 것이 있는데...**
> adder1.add로 실행해서 확인하는데, 왜... -> (map이 람다식을 실행해 준다는 이야기)
> 그게 제어의 역전이라고 설명이 되있는거에 private B b라고만 적혀있어서 이거만 인줄 알았어. ->  .map .filter .orElseThrow 전부 멋대로 실행하는 것도 제어의 역전이라는 이야기

```스프링에서 말하는 IoC는 크게 두 영역으로 나뉩니다.
구분,객체 관리의 IoC (스프링 컨테이너),실행 흐름의 IoC (람다/템플릿)
핵심 코드,private B b; (필드 선언만 함),.filter(p -> ...) (쪽지만 넘김)
내용,"""객체 생성은 내가 안 해, 스프링이 필요할 때 넣어줘.""","""반복문은 내가 안 돌려, 기계가 알아서 실행해줘."""
주도권,객체의 생명주기를 맡김,메서드 실행 시점을 맡김
```

---


# 발단은 람다식

그럼요! 방금 우리가 이야기한 **"기본형"**과 **"개조형(익명 클래스)"**의 차이를 한눈에 볼 수 있도록 전체 코드를 짜드릴게요.

이 코드를 실행해 본다고 상상하면서 흐름을 따라와 보세요.

---

### 1. 설계도 만들기 (Adder.java)

먼저 기본이 되는 `Adder` 클래스가 있어야겠죠?

```java
class Adder {
    // 기본적으로 두 수를 더해주는 메서드
    public int add(int a, int b) {
        return a + b;
    }
}

```

---

### 2. 실제 사용하기 (Main.java)

이제 메인 코드에서 두 가지 방식으로 객체를 만들어 비교해 보겠습니다.

```java
public class Main {
    public static void main(String[] args) {
        
        // 1번: 일반적인 객체 생성 (기존 설계도 그대로!)
        Adder normalAdder = new Adder();
        System.out.println("기본 더하기: " + normalAdder.add(10, 20)); 
        // 결과: 30 (10 + 20)

        // -------------------------------------------------------

        // 2번: 익명 클래스로 객체 생성 (만들면서 메서드 개조!)
        Adder bonusAdder = new Adder() {
            @Override
            public int add(int a, int b) {
                // 기본 더하기에 보너스 500을 더해주는 특수 개조!
                return a + b + 500;
            }
        }; 
        
        System.out.println("개조된 더하기: " + bonusAdder.add(10, 20));
        // 결과: 530 (10 + 20 + 500)
    }
}

```
---

정확합니다! 완벽하게 꿰뚫어 보셨네요.

질문하신 **"원래 있던 같은 이름의 메서드를 수정하는 게 전제인가?"**에 대한 답은 **"네, 그것이 익명 클래스를 사용하는 가장 주된 목적"**입니다.

조금 더 디테일한 규칙을 덧붙이자면 다음과 같습니다.

---

### 1. 왜 같은 이름의 메서드를 수정(Override)할까?

프로그램을 짤 때, 큰 틀(Adder)은 정해져 있지만 **세부 동작만 살짝 바꾸고 싶을 때**가 많기 때문입니다.

* **전제:** 부모 클래스(`Adder`)에 `add`라는 이름의 메서드가 이미 존재해야 합니다.
* **이유:** 외부에서 `myAdder.add()`를 호출할 때, 컴퓨터는 일단 부모 클래스에 그 메서드가 있는지 확인하거든요. 이름이 다르면 컴퓨터가 찾지 못합니다.

---

### 2. "수정"만 할 수 있나? "추가"는 안 되나?

익명 클래스 안에서 **새로운 메서드를 정의(추가)**하는 것도 문법적으로는 가능합니다. 하지만 **외부에서 쓸 수가 없어서** 거의 하지 않습니다.

```java
Adder myAdder = new Adder() {
    @Override
    public int add(int a, int b) { return a + b; } // 수정 (OK!)

    public void sayHello() { System.out.println("안녕"); } // 추가 (가능은 함)
};

myAdder.add(1, 2);      // 작동 잘 됨
// myAdder.sayHello();  // 에러 발생! (부모인 Adder 설계도에는 sayHello가 없기 때문)

```

그래서 익명 클래스는 보통 **"기존에 약속된 메서드를 내 입맛에 맞게 고쳐 쓴다"**는 용도로만 99% 사용됩니다.

---

### 3. 실전 예시: 이게 진짜 많이 쓰이는 곳

주로 **"클릭 이벤트"** 같은 곳에서 이 문법이 폭발적으로 사용됩니다.

* **부모:** `Button` 클래스에는 `onClick()` (클릭하면 실행될 기능) 메서드가 비어있음.
* **나:** "이번에 만든 `loginButton`은 클릭하면 **로그인 기능**이 돌아가게 `onClick`을 수정할래!"
* **나:** "저번에 만든 `joinButton`은 클릭하면 **회원가입 기능**이 돌아가게 `onClick`을 수정할래!"

이렇게 **틀은 같은데 알맹이만 계속 바꿔야 할 때** 굳이 클래스 파일을 새로 만들지 않고 `{ }`를 열어 즉석에서 수정하는 것이죠.

---

### 📝 최종 정리

1. **기존 메서드 수정:** 핵심 목적입니다. (거의 100%)
2. **이름 일치:** 반드시 부모가 가진 메서드 이름과 똑같아야 합니다. (`@Override`)
3. **일회용:** 이렇게 만든 수정본은 오직 `myAdder`라는 변수 안에서만 유효합니다.

정리하신 문장이 워낙 훌륭해서 그대로 학습 노트에 적어두셔도 좋을 것 같아요! 이제 이 익명 클래스를 더 짧게 줄여 쓰는 **람다(Lambda)**라는 녀석도 궁금해지실 텐데, 그건 나중에 필요할 때 또 물어봐 주세요.

혹시 익명 클래스를 쓰다가 `;` 세미콜론 위치 때문에 에러가 난 적은 없으신가요?

---

# 그럼 add랑 add2가 정의되어있다고 치자. add만 저렇게 고치면 add2도 쓸수는 있는건가?

네, **당연히 쓸 수 있습니다!**

익명 클래스로 `add`만 고쳤다고 해서 `add2`가 사라지는 건 아니에요. `myAdder`는 여전히 `Adder` 클래스의 자식이기 때문에, **고치지 않은 나머지 메서드(`add2`)는 원래 설계도(부모 클래스)에 적힌 그대로** 물려받아 사용할 수 있습니다.

이해를 돕기 위해 코드로 직접 보여드릴게요.

---

### 💻 코드로 확인하기

```java
class Adder {
    public int add(int a, int b) {
        return a + b;
    }

    public int add2(int a, int b) {
        System.out.println("나는 원래 설계도에 있던 add2야!");
        return a + b;
    }
}

public class Main {
    public static void main(String[] args) {
        
        // 익명 클래스로 'add'만 쏙 골라서 개조함
        Adder myAdder = new Adder() {
            @Override
            public int add(int a, int b) {
                return a + b + 100; // 얘만 특별하게 수정!
            }
            // add2는 건드리지 않음 (자동으로 부모 것을 물려받음)
        };

        // 1. 개조한 메서드 실행
        System.out.println(myAdder.add(10, 10));  // 결과: 120 (개조 버전)

        // 2. 건드리지 않은 메서드 실행
        System.out.println(myAdder.add2(10, 10)); // 결과: 20 (원본 버전 그대로 동작!)
    }
}

```

---

### 🧐 왜 가능한가요? (상속의 원리)

자바의 **상속(Inheritance)** 개념 때문입니다.
익명 클래스를 만드는 행위는 사실 **"Adder를 상속받는 이름 없는 자식 클래스를 만드는 것"**과 같아요.

* **수정한 메서드(@Override):** "부모님 방식은 싫어요, 제 방식대로 할게요!" 하고 덮어씌운 것.
* **안 고친 메서드:** "이건 부모님이 물려주신 그대로 쓸게요." 하고 그대로 유지하는 것.

### 💡 핵심 요약

* **선택적 수정:** 모든 메서드를 다 고칠 필요는 없습니다. 내가 바꾸고 싶은 것만 골라서 중괄호 `{ }` 안에 적어주면 됩니다.
* **나머지는 그대로:** 중괄호 안에 적지 않은 나머지 기능들은 원래 `Adder` 클래스에 정의된 대로 똑같이 동작합니다.

정리하자면, 익명 클래스는 **"기존 기능을 다 버리는 것"**이 아니라, **"기본 기능은 유지하되 필요한 부분만 튜닝하는 것"**이라고 이해하시면 정확합니다!

혹시 이 개념을 바탕으로 직접 짜보고 계신 코드가 있나요? `add2` 말고 또 다른 메서드도 같이 고쳐보고 싶으신가요?
